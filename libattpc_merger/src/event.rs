use fxhash::FxHashMap;
use ndarray::{s, Array1, Array2};

use crate::constants::SAMPLE_COLUMN_OFFSET;
use crate::hardware_id::{Detector, SiDetector};

use super::channel_map::GetChannelMap;
use super::constants::{COBO_WITH_TIMESTAMP, FPN_CHANNELS, NUMBER_OF_MATRIX_COLUMNS};
use super::error::EventError;
use super::graw_frame::GrawFrame;
use super::hardware_id::HardwareID;

/// # Event
/// An event is a collection of traces which all occured with the same Event ID generated by the AT-TPC DAQ.
/// An event is created from a Vec of GrawFrames, which are then parsed into ndarray traces. The event can also subtract
/// the fixed pattern noise recored by the electronics. To write the event to HDF5, convert the event to a data matrix.
#[derive(Debug)]
pub struct Event {
    nframes: i32,
    pad_traces: FxHashMap<usize, Array1<i16>>, //maps pad id to the trace for that pad
    upfront_si_traces: FxHashMap<usize, Array1<i16>>, //maps pad id to the trace for that pad
    upback_si_traces: FxHashMap<usize, Array1<i16>>, //maps pad id to the trace for that pad
    downfront_si_traces: FxHashMap<usize, Array1<i16>>, //maps pad id to the trace for that pad
    downback_si_traces: FxHashMap<usize, Array1<i16>>, //maps pad id to the trace for that pad
    pub timestamp: u64,
    pub timestampother: u64,
    pub event_id: u32,
}

impl Event {
    /// Make a new event from a list of GrawFrames
    pub fn new(pad_map: &GetChannelMap, frames: &Vec<GrawFrame>) -> Result<Self, EventError> {
        let mut event = Event {
            nframes: 0,
            pad_traces: FxHashMap::default(),
            upfront_si_traces: FxHashMap::default(),
            upback_si_traces: FxHashMap::default(),
            downfront_si_traces: FxHashMap::default(),
            downback_si_traces: FxHashMap::default(),
            timestamp: 0,
            timestampother: 0,
            event_id: 0,
        };
        for frame in frames {
            event.append_frame(pad_map, frame)?;
        }

        Ok(event)
    }

    /// Convert the event traces to a data matrix for writing to disk. Follows format used by AT-TPC analysis
    pub fn get_pad_data_matrix(&self) -> Array2<i16> {
        todo!();
        let mut data_matrix =
            Array2::<i16>::zeros([self.pad_traces.len(), NUMBER_OF_MATRIX_COLUMNS]);
        for (row, (_hw_id, trace)) in self.pad_traces.iter().enumerate() {
            let mut trace_slice = data_matrix.slice_mut(s![row, ..]);
            trace_slice.copy_from_slice()
        }

        data_matrix
    }

    pub fn get_upstream_front_silicon_data_matrix(&self) -> Array2<i16> {
        let mut data_matrix =
            Array2::<i16>::zeros([self.upfront_si_traces.len(), NUMBER_OF_MATRIX_COLUMNS]);
        for (row, (_hw_id, trace)) in self.upfront_si_traces.iter().enumerate() {
            let mut trace_slice = data_matrix.slice_mut(s![row, 5..NUMBER_OF_MATRIX_COLUMNS]);
            trace.move_into(&mut trace_slice);
        }

        data_matrix
    }

    pub fn get_upstream_back_silicon_data_matrix(&self) -> Array2<i16> {
        let mut data_matrix =
            Array2::<i16>::zeros([self.upback_si_traces.len(), NUMBER_OF_MATRIX_COLUMNS]);
        for (row, (_hw_id, trace)) in self.upback_si_traces.iter().enumerate() {
            let mut trace_slice = data_matrix.slice_mut(s![row, 5..NUMBER_OF_MATRIX_COLUMNS]);
            trace.move_into(&mut trace_slice);
        }

        data_matrix
    }

    pub fn get_downstream_front_silicon_data_matrix(&self) -> Array2<i16> {
        let mut data_matrix =
            Array2::<i16>::zeros([self.downfront_si_traces.len(), NUMBER_OF_MATRIX_COLUMNS]);
        for (row, (_hw_id, trace)) in self.downfront_si_traces.iter().enumerate() {
            let mut trace_slice = data_matrix.slice_mut(s![row, 5..NUMBER_OF_MATRIX_COLUMNS]);
            trace.move_into(&mut trace_slice);
        }

        data_matrix
    }

    pub fn get_downstream_back_silicon_data_matrix(&self) -> Array2<i16> {
        let mut data_matrix =
            Array2::<i16>::zeros([self.downback_si_traces.len(), NUMBER_OF_MATRIX_COLUMNS]);
        for (row, (_hw_id, trace)) in self.downback_si_traces.iter().enumerate() {
            let mut trace_slice = data_matrix.slice_mut(s![row, 5..NUMBER_OF_MATRIX_COLUMNS]);
            trace.move_into(&mut trace_slice);
        }

        data_matrix
    }

    /// Add a frame to the event.
    ///
    /// If the frame does not belong to this event, an error is returned
    fn append_frame(
        &mut self,
        channel_map: &GetChannelMap,
        frame: &GrawFrame,
    ) -> Result<(), EventError> {
        // Check if this is the first frame or that the event id's match
        if self.nframes == 0 {
            self.event_id = frame.header.event_id;
        } else if self.event_id != frame.header.event_id {
            return Err(EventError::MismatchedEventID(
                frame.header.event_id,
                self.event_id,
            ));
        }

        if frame.header.cobo_id == COBO_WITH_TIMESTAMP {
            // this cobo has a TS in sync with other DAQ
            self.timestampother = frame.header.event_time;
        } else {
            // all other cobos have the same TS from Mutant
            self.timestamp = frame.header.event_time;
        }

        let mut hw_id: &HardwareID;
        for datum in frame.data.iter() {
            // Reject FPN channels
            if FPN_CHANNELS.contains(&datum.channel) {
                continue;
            }

            // Get the hardware ID
            hw_id = match channel_map.get_hardware_id(
                &frame.header.cobo_id,
                &frame.header.asad_id,
                &datum.aget_id,
                &datum.channel,
            ) {
                Some(hw) => hw,
                None => {
                    spdlog::warn!(
                        "Unregistered GET channel -- CoBo: {} AsAd: {} AGET: {} Channel: {}",
                        frame.header.cobo_id,
                        frame.header.asad_id,
                        datum.aget_id,
                        datum.channel
                    );
                    continue;
                }
            };

            // Put the data in the appropriate trace
            match &hw_id.detector {
                Detector::Pad(p) => match self.pad_traces.get_mut(&p) {
                    Some(trace) => {
                        trace[datum.time_bucket_id as usize + SAMPLE_COLUMN_OFFSET] = datum.sample
                    }
                    None => {
                        let mut trace: Array1<i16> = Array1::<i16>::zeros(NUMBER_OF_MATRIX_COLUMNS);
                        trace[0] = hw_id.cobo_id as i16;
                        trace[1] = hw_id.asad_id as i16;
                        trace[2] = hw_id.aget_id as i16;
                        trace[3] = hw_id.channel as i16;
                        trace[5] = *p as i16;
                        trace[datum.time_bucket_id as usize + SAMPLE_COLUMN_OFFSET] = datum.sample;
                    }
                },
                Detector::Silicon(s) => {
                    let det_map: &mut FxHashMap<usize, Array1<i16>>;
                    match s.kind {
                        SiDetector::UpstreamFront => det_map = &mut self.upfront_si_traces,
                        SiDetector::UpstreamBack => det_map = &mut self.upback_si_traces,
                        SiDetector::DownstreamBack => det_map = &mut self.downback_si_traces,
                        SiDetector::DownstreamFront => det_map = &mut self.downfront_si_traces,
                    }

                    match det_map.get_mut(&s.channel) {
                        Some(trace) => {
                            trace[datum.time_bucket_id as usize + SAMPLE_COLUMN_OFFSET] =
                                datum.sample
                        }
                        None => {
                            let mut trace: Array1<i16> =
                                Array1::<i16>::zeros(NUMBER_OF_MATRIX_COLUMNS);
                            trace[0] = hw_id.cobo_id as i16;
                            trace[1] = hw_id.asad_id as i16;
                            trace[2] = hw_id.aget_id as i16;
                            trace[3] = hw_id.channel as i16;
                            trace[5] = s.channel as i16;
                            trace[datum.time_bucket_id as usize + SAMPLE_COLUMN_OFFSET] =
                                datum.sample;
                        }
                    }
                }
            }
        }

        self.nframes += 1;

        Ok(())
    }
}
